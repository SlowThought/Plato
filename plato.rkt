#lang racket
#| plato.rkt -- Platonic solids and other shapes are generated by placing mutually repulsive particles on
   a unit shpere and applying Lagrangian mechanics to work out their trajectories until, and if, they
   stablize.
   Written by Patrick King, all rights reserved |#

(provide push-random-particle push-particle pop-last-particle #|update-particles!|# x y z)

;;; Each particle is constrained to the unit sphere. Its position is represented by the angles ϕ (think
;;; longitude) and θ (think latitude).

(define Xs null)
(define Vs null)
(define n_particles 0)

(define (push-random-particle)
  (set! Xs (cons (cons (* (random) 2. pi) (* (- (random) .5) pi)) Xs))
  (set! Vs (cons (cons (* (- (random) .5) .1) (* (- (random) .5) .1)) Vs))
  (set! n_particles (add1 n_particles)))

(define (push-particle ϕ θ) ; A specific position, zero velocity
  (set! Xs (cons (cons ϕ θ) Xs))
  (set! Vs (cons (cons 0. 0.) Vs))
  (set! n_particles (add1 n_particles)))

(define (pop-last-particle)
  (if (= n_particles 0)
      (error "pop-last-particle: no particles to pop!")
      (begin
        (set! Xs (cdr Xs))
        (set! Vs (cdr Vs))
        (set! n_particles (sub1 n_particles)))))

;;; Euler angles are (among?) the most compact representation. We need Cartesian coordinates for plotting
(define (x ϕ θ)
  (* (cos ϕ) (cos θ)))
(define (y ϕ θ)
  (* (sin ϕ) (cos θ)))
(define (z θ)
  (sin θ))

;;; Above structures were designed to ease UI implementation. We will want to cast them for computational
;;; convenience/clarity. All lists to vectors, variables broken out. This may break when I try to update
;;; above lists.
(define-syntax-rule (cast-lists-to-vectors body)
  (begin
    (define ϕ (list->vector (map car Xs)))
    (define θ (list->vector (map cdr Xs)))
    ; Expand later for Vs
    body))
(cast-lists-to-vector "test")
;;; The distance (radius) between particles is figured using cosine rule and half angle room
(define (R i j)
  (cast-lists-to-vectors
   (* (sqrt 2.)
      (sqrt (- 1.
               (* (sin (vector-ref θ i))
                  (sin (vector-ref θ j)))
               (* (cos (- (vector-ref ϕ j)
                          (vector-ref ϕ i)))
                  (cos (vector-ref θ i))
                  (cos (vector-ref θ j))))))))