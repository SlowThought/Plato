#lang racket
#| plato.rkt -- Platonic solids and other shapes are generated by placing mutually repulsive particles on a unit shpere and applying
   Lagrangian mechanics to work out their trajectories until, and if, they stablize.
   Written by Patrick King, all rights reserved |#

;;; Each particle is constrained to the unit sphere. Its position is represented by the angles ϕ (think heading) and θ (think
;;; elevation).

(define Xs null)
(define Vs null)

(define (push-random-particle)
  (set! Xs (cons (cons (* (random) 2. pi) (* (- (random) .5) pi))))
  (set! Vs (cons (cons (* (- (random) .5) .1) (* (- (random) .5) .1)))))

(define (pop-last-particle)
  (set! Xs (cdr Xs))
  (set! Vs (cdr Vs)))

;;; Euler angles are the most compact representation. We need Cartesian coordinates for plotting
(define (x ϕ θ)
  (* (cos ϕ) (cos θ)))
(define (y ϕ θ)
  (* (sin ϕ) (cos θ)))
(define (z θ)
  (sin θ))

;;; Energies are analogous to physical definitions, but arbitrary. Useless constants are dropped. We will end up with n Lagrangians involving 6 derivatives
;;; L = K - P
(define K_i #'(+ (sqr ϕ_dot_i) (sqr θ_dot_i))) ; square of velocities
; Per Maxima, dropping constants, P_ij is 1/R_ij (or some multiple of that) where R is the distance between x_i and x_j
(define P_ij #'(/ (sqrt (- 1
                           (* (sin θ_i)(sin θ_j))
                           (* (cos (- ϕ_j  ϕ_i))(cos θ_i)(cos θ_j))))))

(require "./dwrt.rkt") ; differentiation macros
(dwrt x x)
;; Derivative of Lagrangian wrt each state variable
;; (define dL/dϕ_dot_i (dwrt ϕ_dot_i K_i))
;; 
;; (define dL/dθ_i (- (dwrt θ_i P_ij)))