#lang racket
#| plato.rkt -- Platonic solids and other shapes are generated by placing mutually repulsive particles on
   a unit shpere and applying Lagrangian mechanics to work out their trajectories until, and if, they
   stablize.
   Written by Patrick King, all rights reserved |#

(provide push-random-particle! push-particle! pop-particle! update-particles! x y z)
        ; (for-syntax for-each-particle for-each-pair)

;;; Each particle is constrained to the unit sphere. Its position is represented by the angles ϕ (think
;;; longitude) and θ (think latitude).
;;; The particles' state is held in vectors. Constructors and accessors follow

(define n_particles 0)
(define max_particles 128)

(define (plato-vector)
  (make-vector max_particles 0.))

(define ϕs (plato-vector))
(define θs (plato-vector))
(define ϕds (plato-vector)) ; phi "dots", time derivative of phis
(define θds (plato-vector))

; Syntax required to avoid copying v
(define-syntax-rule (vector-accessor v)
  (λ (i)
    (if (and (< i n_particles)
             (>= i 0))
        (vector-ref v i)
        (error "index out of range"))))

(define ϕ (vector-accessor ϕs))
(define θ (vector-accessor θs))
(define ϕd (vector-accessor ϕds))
(define θd (vector-accessor θds))

(define (push-random-particle!)
  (cond [(< n_particles max_particles) ; if full, silent fail - sim keeps running
         (vector-set! ϕs n_particles (* 2 pi (random)))
         (vector-set! θs n_particles (* (/ pi 2) (- (random) .5)))
         (vector-set! ϕds n_particles (* (- (random) .5) .33))
         (vector-set! θds n_particles (* (- (random) .5) .33))
         (set! n_particles (add1 n_particles))]))

(define (push-particle! ϕ θ) ; A specific position, zero velocity
  (if (< n_particles max_particles)
      (begin
        (vector-set! ϕs n_particles ϕ)
        (vector-set! θs n_particles θ)
        (vector-set! ϕds n_particles 0.)
        (vector-set! θds n_particles 0.)
        (set! n_particles (add1 n_particles)))
      (error "push-particle!: already at max particles")))

(define (pop-particle!)
  (set! n_particles (max 0 (sub1 n_particles))))

;;; Euler angles are (among?) the most compact representation(s?). We need Cartesian coordinates for plotting
(define (x ϕ θ)
  (* (cos ϕ) (cos θ)))
(define (y ϕ θ)
  (* (sin ϕ) (cos θ)))
(define (z θ)
  (sin θ))

;;; A bit of geometry/spherical trig

;; Consider points N, I, J, where N is at the "North Pole", and I and J are random points on
;; the sphere. We use the cosine rule of spherical trig to find the distance between I and J,
;; which is defined here as "c" (opposite the corner angle C = ϕj-ϕi at point N. We actually never
;; use c directly. We then define derivatives to be used in Lagrangian later.
(define (cosc i j)
    (+ (* (sin (θ i)) (sin (θ j)))
       (* (cos (θ i)) (cos (θ j)) (cos (- (ϕ j) (ϕ i))))))
(define (dcosc/dϕi i j)
  (* (cos (θ i)) (cos (θ j)) (sin (- (ϕ j) (ϕ i)))))
(define (dcosc/dθi i j)
  (- (* (cos (θ i)) (sin (θ j)))
     (* (sin (θ i)) (cos (θ j)) (cos (- (ϕ j) (ϕ i))))))

;; The distance between a pair of particles is the chord of the angle c. We solve using Pythagoras.
;; Note below is off by about a factor of two. I dropped the 2s because in the end our energy units
;; are arbitrary, so why carry the constants? The "about" is to avoid divide by zero when particles
;; collide (they shouldn't, but they will).
(define One 1.00000000001)
(define (chord cosc)
  (sqrt (- One cosc)))
(define (dchord/dcosc cosc)
  (/ -1. (chord cosc)))

;;; The potential energy of a pair of particles is proportional to the inverse of their distance
;;; apart (analogous to gravitational, electrical fields)
(define-syntax P
  (syntax-rules ()
    [(P i j)
     (if (= i j) 0. ; Else, PE will be tearing particle apart with infinite energy. If rest of
                    ; implementation is right, this is dead code. Consider inserting error,
                    ; eventually getting rid of if. Or, keep cheap insurance.
         (/ (chord (cosc i j))))]
    [(P)
     (for*/sum [(i (in-range 0 (sub1 n_particles)))
             (j (in-range (add1 i) n_particles))]
       (P i j))]))

(define (dPs i)
  (let [(dP/dϕi 0.)
        (dP/dθi 0.)]
    (for [(j (in-range n_particles))]
      (cond [(not (= i j))
             (let* [(cosc (cosc i j))
                    (chord (chord cosc))
                    (dP/dchord (/ -1. chord chord))
                    (dP/dcosc (* dP/dchord (dchord/dcosc cosc)))]
               (set! dP/dϕi (- dP/dϕi (* dP/dcosc (dcosc/dϕi i j))))
               (set! dP/dθi (- dP/dθi (* dP/dcosc (dcosc/dθi i j)))))]))
    (values dP/dϕi dP/dθi)))

;;; Kinetic energy depends on the velocity of a single particle. It is simply the traditional 1/2 * m * v^2.
;;; Here we keep the half, to make the derivatives cleaner. Again, made up world, constants are arbitrary.
(define-syntax K
  (syntax-rules ()
    [(K i)
     (/ (+ (sqr (ϕd i)) (sqr (θd i))) 2.)]
    [(K)
     (for/sum [(i (in-range n_particles))]
       (K i))]))

(define dK/dϕdi ϕd)
(define dK/dθdi θd)

;;; Lagrangian
; For plots?
(define (L)
  (- (K) (P)))

;; The Lagrangian payoff!
(define (dds i) ; double dots, accelerations
  (let-values ([(phi_dd theta_dd)(dPs i)])
    (values (- phi_dd) (- theta_dd))))

;;; Integrate to update
(define dt (/ 60.))
(define (update-particles!)
  (define new-ϕs (plato-vector))
  (define new-θs (plato-vector))
  (define new-ϕds (plato-vector))
  (define new-θds (plato-vector))
  (for [(i (in-range n_particles))]
    (let-values ([(phi_dd theta_dd)(dds i)])
      (vector-set! new-ϕds i (+ (ϕd i) (* phi_dd dt)))
      (vector-set! new-θds i (+ (θd i) (* theta_dd dt)))
      (vector-set! new-ϕs i
                   (+ (ϕ i) (* (ϕd i) dt)
                      (* 0.5 phi_dd dt dt)))
      (vector-set! new-θs i
                   (+ (θ i) (* (θd i) dt)
                      (* 0.5 theta_dd dt dt)))
  (set!-values (ϕs θs ϕds θds)
               (values new-ϕs new-θs new-ϕds new-θds)))

